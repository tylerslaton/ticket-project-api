const bcrypt = require('bcrypt');

'use strict';
const {
  Model
} = require('sequelize');
module.exports = (sequelize, DataTypes) => {
  class User extends Model {
    /**
     * Helper method for defining associations.
     * This method is not a part of Sequelize lifecycle.
     * The `models/index` file will call this method automatically.
     */
    static associate(models) {
      // define association here
      User.hasMany(models.AuthToken);
    }
  };

  // Need to attach to prototype in order to add custom instance level 
  // functions (lets us access the this value). This will take the current
  // user and authorize them.
  User.prototype.authorize = async function () {
    const { AuthToken } = sequelize.models;
    const user = this

    // Reach out to the AuthToken model to generate it based on this
    // user's id.
    const authToken = await AuthToken.generate(this.id);

    // addAuthToken is generated by sequelize due to the hasMany 
    // relationship we established above.
    await user.addAuthToken(authToken);

    return { user, authToken }
  };

  // Define the functionality for logging out. Again, attach to the prototype
  // in order to get access to the this property.
  User.prototype.logout = async function (token) {
    // Take the token and cast it into the fire. 
    sequelize.models.AuthToken.destroy({ where: { token } });
  };

  // Custom function to handle authentication. Takes a username and password
  // and attempts to find a user that matches it. 
  User.authenticate = async function(username, password) {
    console.log(username, password);
    const user = await User.findOne({ where: { username } });

    // Make sure that a user is found
    if( !user ){
      throw new Error('no user found');
    }

    console.log(user);

    // Once we find a user, compare the sent value with the store
    // encrypted value. Ensures no one ever has access to the real
    // unencrypted password.
    if (bcrypt.compareSync(password, user.password)) {
      return user.authorize();
    }

    throw new Error('invalid password');
  }

  // Make sure the critical values can not be null.
  User.init({
    email: {
      type: DataTypes.STRING,
      unique: true,
      allowNull: false
    },
    username: {
      type: DataTypes.STRING,
      unique: true,
      allowNull: false
    },
    password: {
      type: DataTypes.STRING,
      allowNull: false
    }
  }, {
    sequelize,
    modelName: 'User',
  });
  return User;
};